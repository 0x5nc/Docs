<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Routing to Controller Actions </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Routing to Controller Actions ">
    <meta name="generator" content="docfx 2.24.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="/foo">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="mvc/controllers/routing">
<h1 id="routing-to-controller-actions" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="15" sourceendlinenumber="15">Routing to Controller Actions</h1>

<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="17" sourceendlinenumber="17">By <a href="https://github.com/rynowak" data-raw-source="[Ryan Nowak](https://github.com/rynowak)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="17" sourceendlinenumber="17">Ryan Nowak</a> and <a href="https://twitter.com/RickAndMSFT" data-raw-source="[Rick Anderson](https://twitter.com/RickAndMSFT)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="17" sourceendlinenumber="17">Rick Anderson</a></p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="19" sourceendlinenumber="19">ASP.NET Core MVC uses the Routing <a href="../../fundamentals/middleware.html" data-raw-source="[middleware](../../fundamentals/middleware.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="19" sourceendlinenumber="19">middleware</a> to match the URLs of incoming requests and map them to actions. Routes are defined in startup code or attributes. Routes describe how URL paths should be matched to actions. Routes are also used to generate URLs (for links) sent out in responses. </p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="21" sourceendlinenumber="21">Actions are either conventionally routed or attribute routed. Placing a route on the controller or the action makes it attribute routed. See <a href="#routing-mixed-ref-label" data-raw-source="[Mixed routing](#routing-mixed-ref-label)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="21" sourceendlinenumber="21">Mixed routing</a> for more information.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="23" sourceendlinenumber="23">This document will explain the interactions between MVC and routing, and how typical MVC apps make use of routing features. See <a class="xref" href="../../fundamentals/routing.html" data-raw-source="[Routing](xref:fundamentals/routing)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="23" sourceendlinenumber="23">Routing</a> for details on advanced routing.</p>
<h2 id="setting-up-routing-middleware" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="25" sourceendlinenumber="25">Setting up Routing Middleware</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="27" sourceendlinenumber="27">In your <em>Configure</em> method you may see code similar to:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="29" sourceendlinenumber="34"><code class="lang-csharp">app.UseMvc(routes =&gt;
{
   routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="36" sourceendlinenumber="36">Inside the call to <code>UseMvc</code>, <code>MapRoute</code> is used to create a single route, which we&#39;ll refer to as the <code>default</code> route. Most MVC apps will use a route with a template similar to the <code>default</code> route.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="38" sourceendlinenumber="38">The route template <code>&quot;{controller=Home}/{action=Index}/{id?}&quot;</code> can match a URL path like <code>/Products/Details/5</code> and will extract the route values <code>{ controller = Products, action = Details, id = 5 }</code> by tokenizing the path. MVC will attempt to locate a controller named <code>ProductsController</code> and run the action <code>Details</code>:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="40" sourceendlinenumber="45"><code class="lang-csharp">public class ProductsController : Controller
{
   public IActionResult Details(int id) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="47" sourceendlinenumber="47">Note that in this example, model binding would use the value of <code>id = 5</code> to set the <code>id</code> parameter to <code>5</code> when invoking this action. See the <a href="../models/model-binding.html" data-raw-source="[Model Binding](../models/model-binding.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="47" sourceendlinenumber="47">Model Binding</a> for more details.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="49" sourceendlinenumber="49">Using the <code>default</code> route:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="51" sourceendlinenumber="53"><code class="lang-csharp">routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="55" sourceendlinenumber="55">The route template:</p>
<ul sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="57" sourceendlinenumber="61">
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="57" sourceendlinenumber="57"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="57" sourceendlinenumber="57"><code>{controller=Home}</code> defines <code>Home</code> as the default <code>controller</code></p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="59" sourceendlinenumber="59"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="59" sourceendlinenumber="59"><code>{action=Index}</code> defines <code>Index</code> as the default <code>action</code></p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="61" sourceendlinenumber="61"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="61" sourceendlinenumber="61"><code>{id?}</code> defines <code>id</code> as optional</p>
</li>
</ul>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="63" sourceendlinenumber="63">Default and optional route parameters do not need to be present in the URL path for a match. See <a href="../../fundamentals/routing.html#route-template-reference" data-raw-source="[Route Template Reference](../../fundamentals/routing.md#route-template-reference)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="63" sourceendlinenumber="63">Route Template Reference</a> for a detailed description of route template syntax.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="65" sourceendlinenumber="65"><code>&quot;{controller=Home}/{action=Index}/{id?}&quot;</code> can match the URL path <code>/</code> and will produce the route values <code>{ controller = Home, action = Index }</code>. The values for <code>controller</code> and <code>action</code> make use of the default values, <code>id</code> does not produce a value since there is no corresponding segment in the URL path. MVC would use these route values to select the <code>HomeController</code> and <code>Index</code> action:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="67" sourceendlinenumber="72"><code class="lang-csharp">public class HomeController : Controller
{
  public IActionResult Index() { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="74" sourceendlinenumber="74">Using this controller definition and route template, the <code>HomeController.Index</code> action would be executed for any of the following URL paths:</p>
<ul sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="76" sourceendlinenumber="82">
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="76" sourceendlinenumber="76"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="76" sourceendlinenumber="76"><code>/Home/Index/17</code></p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="78" sourceendlinenumber="78"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="78" sourceendlinenumber="78"><code>/Home/Index</code></p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="80" sourceendlinenumber="80"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="80" sourceendlinenumber="80"><code>/Home</code></p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="82" sourceendlinenumber="82"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="82" sourceendlinenumber="82"><code>/</code></p>
</li>
</ul>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="84" sourceendlinenumber="84">The convenience method <code>UseMvcWithDefaultRoute</code>:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="86" sourceendlinenumber="88"><code class="lang-csharp">app.UseMvcWithDefaultRoute();
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="90" sourceendlinenumber="90">Can be used to replace:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="92" sourceendlinenumber="97"><code class="lang-csharp">app.UseMvc(routes =&gt;
{
   routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="99" sourceendlinenumber="99"><code>UseMvc</code> and <code>UseMvcWithDefaultRoute</code> add an instance of <code>RouterMiddleware</code> to the middleware pipeline. MVC doesn&#39;t interact directly with middleware, and uses routing to handle requests. MVC is connected to the routes through an instance of <code>MvcRouteHandler</code>. The code inside of <code>UseMvc</code> is similar to the following:</p>
<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="103" sourceendlinenumber="114"><code class="lang-csharp">var routes = new RouteBuilder(app);

// Add connection to MVC, will be hooked up by calls to MapRoute.
routes.DefaultHandler = new MvcRouteHandler(...);

// Execute callback to register routes.
// routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);

// Create route collection and add the middleware.
app.UseRouter(routes.Build());
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="116" sourceendlinenumber="116"><code>UseMvc</code> does not directly define any routes, it adds a placeholder to the route collection for the <code>attribute</code> route. The overload <code>UseMvc(Action&lt;IRouteBuilder&gt;)</code> lets you add your own routes and also supports attribute routing.  <code>UseMvc</code> and all of its variations adds a placeholder for the attribute route - attribute routing is always available regardless of how you configure <code>UseMvc</code>. <code>UseMvcWithDefaultRoute</code> defines a default route and supports attribute routing. The <a href="#attribute-routing-ref-label" data-raw-source="[Attribute Routing](#attribute-routing-ref-label)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="116" sourceendlinenumber="116">Attribute Routing</a> section includes more details on attribute routing.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="118" sourceendlinenumber="118"><a name="routing-conventional-ref-label"></a></p>
<h2 id="conventional-routing" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="120" sourceendlinenumber="120">Conventional routing</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="122" sourceendlinenumber="122">The <code>default</code> route:</p>
<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="126" sourceendlinenumber="128"><code class="lang-csharp">routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="130" sourceendlinenumber="130">is an example of a <em>conventional routing</em>. We call this style <em>conventional routing</em> because it establishes a <em>convention</em> for URL paths:</p>
<ul sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="132" sourceendlinenumber="136">
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="132" sourceendlinenumber="132"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="132" sourceendlinenumber="132">the first path segment maps to the controller name</p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="134" sourceendlinenumber="134"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="134" sourceendlinenumber="134">the second maps to the action name.</p>
</li>
<li sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="136" sourceendlinenumber="136"><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="136" sourceendlinenumber="136">the third segment is used for an optional <code>id</code> used to map to a model entity</p>
</li>
</ul>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="138" sourceendlinenumber="138">Using this <code>default</code> route, the URL path <code>/Products/List</code> maps to the <code>ProductsController.List</code> action, and <code>/Blog/Article/17</code> maps to <code>BlogController.Article</code>. This mapping is based on the controller and action names <strong>only</strong> and is not based on namespaces, source file locations, or method parameters.</p>
<div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="140" sourceendlinenumber="140"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="141" sourceendlinenumber="141">Using conventional routing with the default route allows you to build the application quickly without having to come up with a new URL pattern for each action you define. For an application with CRUD style actions, having consistency for the URLs across your controllers can help simplify your code and make your UI more predictable.</p>
</div>
<div class="WARNING" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="143" sourceendlinenumber="143"><h5>Warning</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="144" sourceendlinenumber="144">The <code>id</code> is defined as optional by the route template, meaning that your actions can execute without the ID provided as part of the URL. Usually what will happen if <code>id</code> is omitted from the URL is that it will be set to <code>0</code> by model binding, and as a result no entity will be found in the database matching <code>id == 0</code>. Attribute routing can give you fine-grained control to make the ID required for some actions and not for others. By convention the documentation will include optional parameters like <code>id</code> when they are likely to appear in correct usage.</p>
</div>
<h2 id="multiple-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="146" sourceendlinenumber="146">Multiple routes</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="148" sourceendlinenumber="148">You can add multiple routes inside <code>UseMvc</code> by adding more calls to <code>MapRoute</code>. Doing so allows you to define multiple conventions, or to add conventional routes that are dedicated to a specific action, such as:</p>
<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="152" sourceendlinenumber="159"><code class="lang-csharp">app.UseMvc(routes =&gt;
{
   routes.MapRoute(&quot;blog&quot;, &quot;blog/{*article}&quot;,
            defaults: new { controller = &quot;Blog&quot;, action = &quot;Article&quot; });
   routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="161" sourceendlinenumber="161">The <code>blog</code> route here is a <em>dedicated conventional route</em>, meaning that it uses the conventional routing system, but is dedicated to a specific action. Since <code>controller</code> and <code>action</code> don&#39;t appear in the route template as parameters, they can only have the default values, and thus this route will always map to the action <code>BlogController.Article</code>.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="163" sourceendlinenumber="163">Routes in the route collection are ordered, and will be processed in the order they are added. So in this example, the <code>blog</code> route will be tried before the <code>default</code> route.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="165" sourceendlinenumber="165"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="166" sourceendlinenumber="166"><em>Dedicated conventional routes</em> often use catch-all route parameters like <code>{*article}</code> to capture the remaining portion of the URL path. This can make a route &#39;too greedy&#39; meaning that it matches URLs that you intended to be matched by other routes. Put the &#39;greedy&#39; routes later in the route table to solve this.</p>
</div>
<h3 id="fallback" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="168" sourceendlinenumber="168">Fallback</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="170" sourceendlinenumber="170">As part of request processing, MVC will verify that the route values can be used to find a controller and action in your application. If the route values don&#39;t match an action then the route is not considered a match, and the next route will be tried. This is called <em>fallback</em>, and it&#39;s intended to simplify cases where conventional routes overlap.</p>
<h3 id="disambiguating-actions" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="172" sourceendlinenumber="172">Disambiguating actions</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="174" sourceendlinenumber="174">When two actions match through routing, MVC must disambiguate to choose the &#39;best&#39; candidate or else throw an exception. For example:</p>
<!-- literal_block {"ids": [], "names": [], "backrefs": [], "dupnames": [], "xml:space": "preserve", "classes": []} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="178" sourceendlinenumber="186"><code class="lang-csharp">public class ProductsController : Controller
{
   public IActionResult Edit(int id) { ... }

   [HttpPost]
   public IActionResult Edit(int id, Product product) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="188" sourceendlinenumber="188">This controller defines two actions that would match the URL path <code>/Products/Edit/17</code> and route data <code>{ controller = Products, action = Edit, id = 17 }</code>. This is a typical pattern for MVC controllers where <code>Edit(int)</code> shows a form to edit a product, and <code>Edit(int, Product)</code> processes  the posted form. To make this possible MVC would need to choose <code>Edit(int, Product)</code> when the request is an HTTP <code>POST</code> and <code>Edit(int)</code> when the HTTP verb is anything else.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="190" sourceendlinenumber="190">The <code>HttpPostAttribute</code> ( <code>[HttpPost]</code> ) is an implementation of <code>IActionConstraint</code> that will only allow the action to be selected when the HTTP verb is <code>POST</code>. The presence of an <code>IActionConstraint</code> makes the <code>Edit(int, Product)</code> a &#39;better&#39; match than <code>Edit(int)</code>, so <code>Edit(int, Product)</code> will be tried first.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="192" sourceendlinenumber="192">You will only need to write custom <code>IActionConstraint</code> implementations in specialized scenarios, but it&#39;s important to understand the role of attributes like <code>HttpPostAttribute</code>  - similar attributes are defined for other HTTP verbs. In conventional routing it&#39;s common for actions to use the same action name when they are part of a <code>show form -&gt; submit form</code> workflow. The convenience of this pattern will become more apparent after reviewing the <a href="#understanding-iactionconstraint" data-raw-source="[Understanding IActionConstraint](#understanding-iactionconstraint)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="192" sourceendlinenumber="192">Understanding IActionConstraint</a> section.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="194" sourceendlinenumber="194">If multiple routes match, and MVC can&#39;t find a &#39;best&#39; route, it will throw an <code>AmbiguousActionException</code>.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="196" sourceendlinenumber="196"><a name="routing-route-name-ref-label"></a></p>
<h3 id="route-names" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="198" sourceendlinenumber="198">Route names</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="200" sourceendlinenumber="200">The strings  <code>&quot;blog&quot;</code> and <code>&quot;default&quot;</code> in the following examples are route names:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="203" sourceendlinenumber="210"><code class="lang-csharp">app.UseMvc(routes =&gt;
{
   routes.MapRoute(&quot;blog&quot;, &quot;blog/{*article}&quot;,
               defaults: new { controller = &quot;Blog&quot;, action = &quot;Article&quot; });
   routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="212" sourceendlinenumber="212">The route names give the route a logical name so that the named route can be used for URL generation. This greatly simplifies URL creation when the ordering of routes could make URL generation complicated. Routes names must be unique application-wide.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="214" sourceendlinenumber="214">Route names have no impact on URL matching or handling of requests; they are used only for URL generation. <a class="xref" href="../../fundamentals/routing.html" data-raw-source="[Routing](xref:fundamentals/routing)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="214" sourceendlinenumber="214">Routing</a> has more detailed information on URL generation including URL generation in MVC-specific helpers.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="216" sourceendlinenumber="216"><a name="attribute-routing-ref-label"></a></p>
<h2 id="attribute-routing" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="218" sourceendlinenumber="218">Attribute routing</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="220" sourceendlinenumber="220">Attribute routing uses a set of attributes to map actions directly to route templates. In the following example, <code>app.UseMvc();</code> is used in the <code>Configure</code> method and no route is passed. The <code>HomeController</code> will match a set of URLs similar to what the default route <code>{controller=Home}/{action=Index}/{id?}</code> would match:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="222" sourceendlinenumber="243"><code class="lang-csharp">public class HomeController : Controller
{
   [Route(&quot;&quot;)]
   [Route(&quot;Home&quot;)]
   [Route(&quot;Home/Index&quot;)]
   public IActionResult Index()
   {
      return View();
   }
   [Route(&quot;Home/About&quot;)]
   public IActionResult About()
   {
      return View();
   }
   [Route(&quot;Home/Contact&quot;)]
   public IActionResult Contact()
   {
      return View();
   }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="245" sourceendlinenumber="245">The <code>HomeController.Index()</code> action will be executed for any of the URL paths <code>/</code>, <code>/Home</code>, or <code>/Home/Index</code>.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="247" sourceendlinenumber="247"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="248" sourceendlinenumber="248">This example highlights a key programming difference between attribute routing and conventional routing. Attribute routing requires more input to specify a route; the conventional default route handles routes more succinctly. However, attribute routing allows (and requires) precise control of which route templates apply to each action.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="250" sourceendlinenumber="250">With attribute routing the controller name and action names play <strong>no</strong> role in which action is selected. This example will match the same URLs as the previous example.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="252" sourceendlinenumber="273"><code class="lang-csharp">public class MyDemoController : Controller
{
   [Route(&quot;&quot;)]
   [Route(&quot;Home&quot;)]
   [Route(&quot;Home/Index&quot;)]
   public IActionResult MyIndex()
   {
      return View(&quot;Index&quot;);
   }
   [Route(&quot;Home/About&quot;)]
   public IActionResult MyAbout()
   {
      return View(&quot;About&quot;);
   }
   [Route(&quot;Home/Contact&quot;)]
   public IActionResult MyContact()
   {
      return View(&quot;Contact&quot;);
   }
}
</code></pre><div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="275" sourceendlinenumber="275"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="276" sourceendlinenumber="276">The route templates above don&#39;t define route parameters for <code>action</code>, <code>area</code>, and <code>controller</code>. In fact, these route parameters are not allowed in attribute routes. Since the route template is already associated with an action, it wouldn&#39;t make sense to parse the action name from the URL.</p>
</div>
<h2 id="attribute-routing-with-httpverb-attributes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="278" sourceendlinenumber="278">Attribute routing with Http[Verb] attributes</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="280" sourceendlinenumber="280">Attribute routing can also make use of the <code>Http[Verb]</code> attributes such as <code>HttpPostAttribute</code>. All of these attributes can accept a route template. This example shows two actions that match the same route template:</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="284" sourceendlinenumber="296"><code class="lang-csharp">[HttpGet(&quot;/products&quot;)]
public IActionResult ListProducts()
{
   // ...
}

[HttpPost(&quot;/products&quot;)]
public IActionResult CreateProduct(...)
{
   // ...
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="298" sourceendlinenumber="298">For a URL path like <code>/products</code> the <code>ProductsApi.ListProducts</code> action will be executed when the HTTP verb is <code>GET</code> and <code>ProductsApi.CreateProduct</code> will be executed when the HTTP verb is <code>POST</code>. Attribute routing first matches the URL against the set of route templates defined by route attributes. Once a route template matches, <code>IActionConstraint</code> constraints are applied to determine which actions can be executed.</p>
<div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="300" sourceendlinenumber="300"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="301" sourceendlinenumber="301">When building a REST API, it&#39;s rare that you will want to use <code>[Route(...)]</code> on an action method. It&#39;s better to use the more specific <code>Http*Verb*Attributes</code> to be precise about what your API supports. Clients of REST APIs are expected to know what paths and HTTP verbs map to specific logical operations.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="303" sourceendlinenumber="303">Since an attribute route applies to a specific action, it&#39;s easy to make parameters required as part of the route template definition. In this example, <code>id</code> is required as part of the URL path.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="305" sourceendlinenumber="311"><code class="lang-csharp">public class ProductsApiController : Controller
{
   [HttpGet(&quot;/products/{id}&quot;, Name = &quot;Products_List&quot;)]
   public IActionResult GetProduct(int id) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="313" sourceendlinenumber="313">The <code>ProductsApi.GetProduct(int)</code> action will be executed for a URL path like <code>/products/3</code> but not for a URL path like <code>/products</code>. See <a href="../../fundamentals/routing.html" data-raw-source="[Routing](../../fundamentals/routing.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="313" sourceendlinenumber="313">Routing</a> for a full description of route templates and related options.</p>
<h2 id="route-name" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="315" sourceendlinenumber="315">Route Name</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="317" sourceendlinenumber="317">The following code  defines a <em>route name</em> of <code>Products_List</code>:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="319" sourceendlinenumber="325"><code class="lang-csharp">public class ProductsApiController : Controller
{
   [HttpGet(&quot;/products/{id}&quot;, Name = &quot;Products_List&quot;)]
   public IActionResult GetProduct(int id) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="327" sourceendlinenumber="327">Route names can be used to generate a URL based on a specific route. Route names have no impact on the URL matching behavior of routing and are only used for URL generation. Route names must be unique application-wide.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="329" sourceendlinenumber="329"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="330" sourceendlinenumber="330">Contrast this with the conventional <em>default route</em>, which defines the <code>id</code> parameter as optional (<code>{id?}</code>). This ability to precisely specify APIs has advantages, such as  allowing <code>/products</code> and <code>/products/5</code> to be dispatched to different actions.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="332" sourceendlinenumber="332"><a name="routing-combining-ref-label"></a></p>
<h3 id="combining-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="334" sourceendlinenumber="334">Combining routes</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="336" sourceendlinenumber="336">To make attribute routing less repetitive, route attributes on the controller are combined with route attributes on the individual actions. Any route templates defined on the controller are prepended to route templates on the actions. Placing a route attribute on the controller makes <strong>all</strong> actions in the controller use attribute routing.</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="340" sourceendlinenumber="350"><code class="lang-csharp">[Route(&quot;products&quot;)]
public class ProductsApiController : Controller
{
   [HttpGet]
   public IActionResult ListProducts() { ... }

   [HttpGet(&quot;{id}&quot;)]
   public ActionResult GetProduct(int id) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="352" sourceendlinenumber="352">In this example the URL path <code>/products</code> can match <code>ProductsApi.ListProducts</code>, and the URL path <code>/products/5</code> can match <code>ProductsApi.GetProduct(int)</code>. Both of these actions only match HTTP <code>GET</code> because they are decorated with the <code>HttpGetAttribute</code>.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="354" sourceendlinenumber="354">Route templates applied to an action that begin with a <code>/</code> do not get combined with route templates applied to the controller. This example matches a set of URL paths similar to the <em>default route</em>.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="356" sourceendlinenumber="377"><code class="lang-csharp">[Route(&quot;Home&quot;)]
public class HomeController : Controller
{
    [Route(&quot;&quot;)]      // Combines to define the route template &quot;Home&quot;
    [Route(&quot;Index&quot;)] // Combines to define the route template &quot;Home/Index&quot;
    [Route(&quot;/&quot;)]     // Does not combine, defines the route template &quot;&quot;
    public IActionResult Index()
    {
        ViewData[&quot;Message&quot;] = &quot;Home index&quot;;
        var url = Url.Action(&quot;Index&quot;, &quot;Home&quot;);
        ViewData[&quot;Message&quot;] = &quot;Home index&quot; + &quot;var url = Url.Action; =  &quot; + url;
        return View();
    }

    [Route(&quot;About&quot;)] // Combines to define the route template &quot;Home/About&quot;
    public IActionResult About()
    {
        return View();
    }   
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="379" sourceendlinenumber="379"><a name="routing-ordering-ref-label"></a></p>
<h3 id="ordering-attribute-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="381" sourceendlinenumber="381">Ordering attribute routes</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="383" sourceendlinenumber="383">In contrast to conventional routes which execute in a defined order, attribute routing builds a tree and matches all routes simultaneously. This behaves as-if the route entries were placed in an ideal ordering; the most specific routes have a chance to execute before the more general routes.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="385" sourceendlinenumber="385">For example, a route like <code>blog/search/{topic}</code> is more specific than a route like <code>blog/{*article}</code>. Logically speaking the <code>blog/search/{topic}</code> route &#39;runs&#39; first, by default, because that&#39;s the only sensible ordering. Using conventional routing, the developer is  responsible for placing routes in the desired order.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="387" sourceendlinenumber="387">Attribute routes can configure an order, using the <code>Order</code> property of all of the framework provided route attributes. Routes are processed according to an ascending sort of the <code>Order</code> property. The default order is <code>0</code>. Setting a route using <code>Order = -1</code> will run before routes that don&#39;t set an order. Setting a route using <code>Order = 1</code> will run after default route ordering.</p>
<div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="389" sourceendlinenumber="389"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="390" sourceendlinenumber="390">Avoid depending on <code>Order</code>. If your URL-space requires explicit order values to route correctly, then it&#39;s likely confusing to clients as well. In general attribute routing will select the correct route with URL matching. If the default order used for URL generation isn&#39;t working, using route name as an override is usually simpler than applying the <code>Order</code> property.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="392" sourceendlinenumber="392"><a name="routing-token-replacement-templates-ref-label"></a></p>
<h2 id="token-replacement-in-route-templates-controller-action-area" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="394" sourceendlinenumber="394">Token replacement in route templates ([controller], [action], [area])</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="396" sourceendlinenumber="396">For convenience, attribute routes support <em>token replacement</em> by enclosing a token in square-braces (<code>[</code>, <code>]</code>). The tokens <code>[action]</code>, <code>[area]</code>, and <code>[controller]</code> will be replaced with the values of the action name, area name, and controller name from the action where the route is defined. In this example the actions can match URL paths as described in the comments:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="398" sourceendlinenumber="398"><code class="lang-csharp" name="Main">[Route(&quot;[controller]/[action]&quot;)]
public class ProductsController : Controller
{
    [HttpGet] // Matches &#39;/Products/List&#39;
    public IActionResult List() {
        // ...
    }

    [HttpGet(&quot;{id}&quot;)] // Matches &#39;/Products/Edit/{id}&#39;
    public IActionResult Edit(int id) {
        // ...
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="400" sourceendlinenumber="400">Token replacement occurs as the last step of building the attribute routes. The above example will behave the same as the following code:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="402" sourceendlinenumber="402"><code class="lang-csharp" name="Main">
public class ProductsController : Controller
{
    [HttpGet(&quot;[controller]/[action]&quot;)] // Matches &#39;/Products/List&#39;
    public IActionResult List() {
        // ...
    }

    [HttpGet(&quot;[controller]/[action]/{id}&quot;)] // Matches &#39;/Products/Edit/{id}&#39;
    public IActionResult Edit(int id) {
        // ...
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="404" sourceendlinenumber="404">Attribute routes can also be combined with inheritance. This is particularly powerful combined with token replacement.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="406" sourceendlinenumber="418"><code class="lang-csharp">[Route(&quot;api/[controller]&quot;)]
public abstract class MyBaseController : Controller { ... }

public class ProductsController : MyBaseController
{
   [HttpGet] // Matches &#39;/api/Products&#39;
   public IActionResult List() { ... }

   [HttpPost(&quot;{id}&quot;)] // Matches &#39;/api/Products/{id}&#39;
   public IActionResult Edit(int id) { ... }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="420" sourceendlinenumber="420">Token replacement also applies to route names defined by attribute routes. <code>[Route(&quot;[controller]/[action]&quot;, Name=&quot;[controller]_[action]&quot;)]</code> will generate a unique route name for each action.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="422" sourceendlinenumber="422">To match the literal token replacement delimiter <code>[</code> or  <code>]</code>, escape it by repeating the character (<code>[[</code> or <code>]]</code>).</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="424" sourceendlinenumber="424"><a name="routing-multiple-routes-ref-label"></a></p>
<h3 id="multiple-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="426" sourceendlinenumber="426">Multiple Routes</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="428" sourceendlinenumber="428">Attribute routing supports defining multiple routes that reach the same action. The most common usage of this is to mimic the behavior of the <em>default conventional route</em> as shown in the following example:</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="432" sourceendlinenumber="440"><code class="lang-csharp">[Route(&quot;[controller]&quot;)]
public class ProductsController : Controller
{
   [Route(&quot;&quot;)]     // Matches &#39;Products&#39;
   [Route(&quot;Index&quot;)] // Matches &#39;Products/Index&#39;
   public IActionResult Index()
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="442" sourceendlinenumber="442">Putting multiple route attributes on the controller means that each one will combine with each of the route attributes on the action methods.</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="446" sourceendlinenumber="455"><code class="lang-csharp">[Route(&quot;Store&quot;)]
[Route(&quot;[controller]&quot;)]
public class ProductsController : Controller
{
   [HttpPost(&quot;Buy&quot;)]     // Matches &#39;Products/Buy&#39; and &#39;Store/Buy&#39;
   [HttpPost(&quot;Checkout&quot;)] // Matches &#39;Products/Checkout&#39; and &#39;Store/Checkout&#39;
   public IActionResult Buy()
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="457" sourceendlinenumber="457">When multiple route attributes (that implement <code>IActionConstraint</code>) are placed on an action, then each action constraint combines with the route template from the attribute that defined it.</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="461" sourceendlinenumber="469"><code class="lang-csharp">[Route(&quot;api/[controller]&quot;)]
public class ProductsController : Controller
{
   [HttpPut(&quot;Buy&quot;)]      // Matches PUT &#39;api/Products/Buy&#39;
   [HttpPost(&quot;Checkout&quot;)] // Matches POST &#39;api/Products/Checkout&#39;
   public IActionResult Buy()
}
</code></pre><div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="471" sourceendlinenumber="471"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="472" sourceendlinenumber="472">While using multiple routes on actions can seem powerful, it&#39;s better to keep your application&#39;s URL space simple and well-defined. Use multiple routes on actions only where needed, for example to support existing clients.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="474" sourceendlinenumber="474"><a name="routing-attr-options"></a></p>
<h3 id="specifying-attribute-route-optional-parameters-default-values-and-constraints" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="476" sourceendlinenumber="476">Specifying attribute route optional parameters, default values, and constraints</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="478" sourceendlinenumber="478">Attribute routes support the same inline syntax as conventional routes to specify optional parameters, default values, and constraints.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="480" sourceendlinenumber="486"><code class="lang-csharp">[HttpPost(&quot;product/{id:int}&quot;)]
public IActionResult ShowProduct(int id)
{
   // ...
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="488" sourceendlinenumber="488">See <a href="../../fundamentals/routing.html#route-template-reference" data-raw-source="[Route Template Reference](../../fundamentals/routing.md#route-template-reference)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="488" sourceendlinenumber="488">Route Template Reference</a> for a detailed description of route template syntax.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="490" sourceendlinenumber="490"><a name="routing-cust-rt-attr-irt-ref-label"></a></p>
<h3 id="custom-route-attributes-using-iroutetemplateprovider" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="492" sourceendlinenumber="492">Custom route attributes using <code>IRouteTemplateProvider</code></h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="494" sourceendlinenumber="494">All of the route attributes provided in the framework ( <code>[Route(...)]</code>, <code>[HttpGet(...)]</code> , etc.) implement the <code>IRouteTemplateProvider</code> interface. MVC looks for attributes on controller classes and action methods when the app starts and uses the ones that implement <code>IRouteTemplateProvider</code> to build the initial set of routes.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="496" sourceendlinenumber="496">You can implement <code>IRouteTemplateProvider</code> to define your own route attributes. Each <code>IRouteTemplateProvider</code> allows you to define a single route with a custom route template, order, and name:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="498" sourceendlinenumber="507"><code class="lang-csharp">public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider
{
   public string Template =&gt; &quot;api/[controller]&quot;;

   public int? Order { get; set; }

   public string Name { get; set; }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="509" sourceendlinenumber="509">The attribute from the above example automatically sets the <code>Template</code> to <code>&quot;api/[controller]&quot;</code> when <code>[MyApiController]</code> is applied.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="511" sourceendlinenumber="511"><a name="routing-app-model-ref-label"></a></p>
<h3 id="using-application-model-to-customize-attribute-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="513" sourceendlinenumber="513">Using Application Model to customize attribute routes</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="515" sourceendlinenumber="515">The <em>application model</em> is an object model created at startup with all of the metadata used by MVC to route and execute your actions. The <em>application model</em> includes all of the data gathered from route attributes (through <code>IRouteTemplateProvider</code>). You can write <em>conventions</em> to modify the application model at startup time to customize how routing behaves. This section shows a simple example of customizing routing using application model.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="517" sourceendlinenumber="517"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc.ApplicationModels;
using System.Linq;
using System.Text;
public class NamespaceRoutingConvention : IControllerModelConvention
{
    private readonly string _baseNamespace;

    public NamespaceRoutingConvention(string baseNamespace)
    {
        _baseNamespace = baseNamespace;
    }

    public void Apply(ControllerModel controller)
    {
        var hasRouteAttributes = controller.Selectors.Any(selector =&gt;
                                                selector.AttributeRouteModel != null);
        if (hasRouteAttributes)
        {
            // This controller manually defined some routes, so treat this 
            // as an override and not apply the convention here.
            return;
        }

        // Use the namespace and controller name to infer a route for the controller.
        //
        // Example:
        //
        //  controller.ControllerTypeInfo -&gt;    &quot;My.Application.Admin.UsersController&quot;
        //  baseNamespace -&gt;                    &quot;My.Application&quot;
        //
        //  template =&gt;                         &quot;Admin/[controller]&quot;
        //
        // This makes your routes roughly line up with the folder structure of your project.
        //
        var namespc = controller.ControllerType.Namespace;

        var template = new StringBuilder();
        template.Append(namespc, _baseNamespace.Length + 1,
                        namespc.Length - _baseNamespace.Length - 1);
        template.Replace(&#39;.&#39;, &#39;/&#39;);
        template.Append(&quot;/[controller]&quot;);

        foreach (var selector in controller.Selectors)
        {
            selector.AttributeRouteModel = new AttributeRouteModel()
            {
                Template = template.ToString()
            };
        }
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="519" sourceendlinenumber="519"><a name="routing-mixed-ref-label"></a></p>
<h2 id="mixed-routing-attribute-routing-vs-conventional-routing" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="521" sourceendlinenumber="521">Mixed routing: Attribute routing vs conventional routing</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="523" sourceendlinenumber="523">MVC applications can mix the use of conventional routing and attribute routing. It&#39;s typical to use conventional routes for controllers serving HTML pages for browsers, and attribute routing for controllers serving REST APIs.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="525" sourceendlinenumber="525">Actions are either conventionally routed or attribute routed. Placing a route on the controller or the action makes it attribute routed. Actions that define attribute routes cannot be reached through the conventional routes and vice-versa. <strong>Any</strong> route attribute on the controller makes all actions in the controller attribute routed.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="527" sourceendlinenumber="527"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="528" sourceendlinenumber="528">What distinguishes the two types of routing systems is the process applied after a URL matches a route template. In conventional routing, the route values from the match are used to choose the action and controller from a lookup table of all conventional routed actions. In attribute routing, each template is already associated with an action, and no further lookup is needed.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="530" sourceendlinenumber="530"><a name="routing-url-gen-ref-label"></a></p>
<h2 id="url-generation" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="532" sourceendlinenumber="532">URL Generation</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="534" sourceendlinenumber="534">MVC applications can use routing&#39;s URL generation features to generate URL links to actions. Generating URLs eliminates hardcoding URLs, making your code more robust and maintainable. This section focuses on the URL generation features provided by MVC and will only cover basics of how URL generation works. See <a href="../../fundamentals/routing.html" data-raw-source="[Routing](../../fundamentals/routing.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="534" sourceendlinenumber="534">Routing</a> for a detailed description of URL generation.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="536" sourceendlinenumber="536">The <code>IUrlHelper</code> interface is the underlying piece of infrastructure between MVC and routing for URL generation. You&#39;ll find an instance of <code>IUrlHelper</code> available through the <code>Url</code> property in controllers, views, and view components.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="538" sourceendlinenumber="538">In this example, the <code>IUrlHelper</code> interface is used through the <code>Controller.Url</code> property to generate a URL to another action.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="540" sourceendlinenumber="540"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

public class UrlGenerationController : Controller
{
    public IActionResult Source()
    {
        // Generates /UrlGeneration/Destination
        var url = Url.Action(&quot;Destination&quot;);
        return Content($&quot;Go check out {url}, it&#39;s really great.&quot;);
    }

    public IActionResult Destination()
    {
        return View();
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="542" sourceendlinenumber="542">If the application is using the default conventional route, the value of the <code>url</code> variable will be the URL path string <code>/UrlGeneration/Destination</code>. This URL path is created by routing by combining the route values from the current request (ambient values), with the values passed to <code>Url.Action</code> and substituting those values into the route template:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="544" sourceendlinenumber="550"><code>ambient values: { controller = &quot;UrlGeneration&quot;, action = &quot;Source&quot; }
values passed to Url.Action: { controller = &quot;UrlGeneration&quot;, action = &quot;Destination&quot; }
route template: {controller}/{action}/{id?}

result: /UrlGeneration/Destination
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="552" sourceendlinenumber="552">Each route parameter in the route template has its value substituted by matching names with the values and ambient values. A route parameter that does not have a value can use a default value if it has one, or be skipped if it is optional (as in the case of <code>id</code> in this example). URL generation will fail if any required route parameter doesn&#39;t have a corresponding value. If URL generation fails for a route, the next route is tried until all routes have been tried or a match is found.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="554" sourceendlinenumber="554">The example of <code>Url.Action</code> above assumes conventional routing, but URL generation works similarly with attribute routing, though the concepts are different. With conventional routing, the route values are used to expand a template, and the route values for <code>controller</code> and <code>action</code> usually appear in that template - this works because the URLs matched by routing adhere to a <em>convention</em>. In attribute routing, the route values for <code>controller</code> and <code>action</code> are not allowed to appear in the template - they are instead used to look up which template to use.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="556" sourceendlinenumber="556">This example uses attribute routing:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="558" sourceendlinenumber="558"><code class="lang-csharp" name="Main">// In Startup class
public void Configure(IApplicationBuilder app)
{
    app.UseMvc();
}
</code></pre><pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="560" sourceendlinenumber="560"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

public class UrlGenerationController : Controller
{
    [HttpGet(&quot;&quot;)]
    public IActionResult Source()
    {
        var url = Url.Action(&quot;Destination&quot;); // Generates /custom/url/to/destination
        return Content($&quot;Go check out {url}, it&#39;s really great.&quot;);
    }

    [HttpGet(&quot;custom/url/to/destination&quot;)]
    public IActionResult Destination() {
        return View();
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="562" sourceendlinenumber="562">MVC builds a lookup table of all attribute routed actions and will match the <code>controller</code> and <code>action</code> values to select the route template to use for URL generation. In the sample above,   <code>custom/url/to/destination</code> is generated.</p>
<h3 id="generating-urls-by-action-name" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="564" sourceendlinenumber="564">Generating URLs by action name</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="566" sourceendlinenumber="566"><code>Url.Action</code> (<code>IUrlHelper</code> . <code>Action</code>) and all related overloads all are based on that idea that you want to specify what you&#39;re linking to by specifying a controller name and action name.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="568" sourceendlinenumber="568"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="569" sourceendlinenumber="569">When using <code>Url.Action</code>, the current route values for <code>controller</code> and <code>action</code> are specified for you - the value of <code>controller</code> and <code>action</code> are part of both <em>ambient values</em> <strong>and</strong> <em>values</em>. The method <code>Url.Action</code>, always uses the current values of <code>action</code> and <code>controller</code> and will generate a URL path that routes to the current action.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="571" sourceendlinenumber="571">Routing attempts to use the values in ambient values to fill in information that you didn&#39;t provide when generating a URL. Using a route like <code>{a}/{b}/{c}/{d}</code> and ambient values <code>{ a = Alice, b = Bob, c = Carol, d = David }</code>, routing has enough information to generate a URL without any additional values - since all route parameters have a value. If you added the value <code>{ d = Donovan }</code>, the value <code>{ d = David }</code> would be ignored, and the generated URL path would be <code>Alice/Bob/Carol/Donovan</code>.</p>
<div class="WARNING" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="573" sourceendlinenumber="573"><h5>Warning</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="574" sourceendlinenumber="574">URL paths are hierarchical. In the example above, if you added the value <code>{ c = Cheryl }</code>, both of the values <code>{ c = Carol, d = David }</code> would be ignored. In this case we no longer have a value for <code>d</code> and URL generation will fail. You would need to specify the desired value of <code>c</code> and <code>d</code>.  You might expect to hit this problem with the default route (<code>{controller}/{action}/{id?}</code>) - but you will rarely encounter this behavior in practice as <code>Url.Action</code> will always explicitly specify a <code>controller</code> and <code>action</code> value.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="576" sourceendlinenumber="576">Longer overloads of <code>Url.Action</code> also take an additional <em>route values</em> object to provide values for route parameters other than <code>controller</code> and <code>action</code>. You will most commonly see this used with <code>id</code> like <code>Url.Action(&quot;Buy&quot;, &quot;Products&quot;, new { id = 17 })</code>. By convention the <em>route values</em> object is usually an object of anonymous type, but it can also be an <code>IDictionary&lt;&gt;</code> or a <em>plain old .NET object</em>. Any additional route values that don&#39;t match route parameters are put in the query string.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="578" sourceendlinenumber="578"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

public class TestController : Controller
{
    public IActionResult Index()
    {
        // Generates /Products/Buy/17?color=red
        var url = Url.Action(&quot;Buy&quot;, &quot;Products&quot;, new { id = 17, color = &quot;red&quot; });
        return Content(url);
    }
}
</code></pre><div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="580" sourceendlinenumber="580"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="581" sourceendlinenumber="581">To create an absolute URL, use an overload that accepts a <code>protocol</code>: <code>Url.Action(&quot;Buy&quot;, &quot;Products&quot;, new { id = 17 }, protocol: Request.Scheme)</code></p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="583" sourceendlinenumber="583"><a name="routing-gen-urls-route-ref-label"></a></p>
<h3 id="generating-urls-by-route" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="585" sourceendlinenumber="585">Generating URLs by route</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="587" sourceendlinenumber="587">The code above demonstrated generating a URL by passing in the controller and action name. <code>IUrlHelper</code> also provides the <code>Url.RouteUrl</code> family of methods. These methods are similar to <code>Url.Action</code>, but they do not copy the current values of <code>action</code> and <code>controller</code> to the route values. The most common usage is to specify a route name to use a specific route to generate the URL, generally <em>without</em> specifying a controller or action name.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="589" sourceendlinenumber="589"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

public class UrlGenerationController : Controller
{
    [HttpGet(&quot;&quot;)]
    public IActionResult Source()
    {
        var url = Url.RouteUrl(&quot;Destination_Route&quot;); // Generates /custom/url/to/destination
        return Content($&quot;See {url}, it&#39;s really great.&quot;);
    }

    [HttpGet(&quot;custom/url/to/destination&quot;, Name = &quot;Destination_Route&quot;)]
    public IActionResult Destination() {
        return View();
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="591" sourceendlinenumber="591"><a name="routing-gen-urls-html-ref-label"></a></p>
<h3 id="generating-urls-in-html" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="593" sourceendlinenumber="593">Generating URLs in HTML</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="595" sourceendlinenumber="595"><code>IHtmlHelper</code> provides the <code>HtmlHelper</code> methods <code>Html.BeginForm</code> and <code>Html.ActionLink</code> to generate <code>&lt;form&gt;</code> and <code>&lt;a&gt;</code> elements respectively. These methods use the <code>Url.Action</code> method to generate a URL and they accept similar arguments. The <code>Url.RouteUrl</code> companions for <code>HtmlHelper</code> are <code>Html.BeginRouteForm</code> and <code>Html.RouteLink</code> which have similar functionality.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="597" sourceendlinenumber="597">TagHelpers generate URLs through the <code>form</code> TagHelper and the <code>&lt;a&gt;</code> TagHelper. Both of these use <code>IUrlHelper</code> for their implementation. See <a href="../views/working-with-forms.html" data-raw-source="[Working with Forms](../views/working-with-forms.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="597" sourceendlinenumber="597">Working with Forms</a> for more information.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="599" sourceendlinenumber="599">Inside views, the <code>IUrlHelper</code> is available through the <code>Url</code> property for any ad-hoc URL generation not covered by the above.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="601" sourceendlinenumber="601"><a name="routing-gen-urls-action-ref-label"></a></p>
<h3 id="generating-urls-in-action-results" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="603" sourceendlinenumber="603">Generating URLS in Action Results</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="605" sourceendlinenumber="605">The examples above have shown using <code>IUrlHelper</code> in a controller, while the most common usage in a controller is to generate a URL as part of an action result.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="607" sourceendlinenumber="607">The <code>ControllerBase</code> and <code>Controller</code> base classes provide convenience methods for action results that reference another action. One typical usage is to redirect after accepting user input.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="609" sourceendlinenumber="618"><code class="lang-csharp">public Task&lt;IActionResult&gt; Edit(int id, Customer customer)
{
    if (ModelState.IsValid)
    {
        // Update DB with new details.
        return RedirectToAction(&quot;Index&quot;);
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="620" sourceendlinenumber="620">The action results factory methods follow a similar pattern to the methods on <code>IUrlHelper</code>.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="622" sourceendlinenumber="622"><a name="routing-dedicated-ref-label"></a></p>
<h3 id="special-case-for-dedicated-conventional-routes" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="624" sourceendlinenumber="624">Special case for dedicated conventional routes</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="626" sourceendlinenumber="626">Conventional routing can use a special kind of route definition called a <em>dedicated conventional route</em>. In the example below, the route named <code>blog</code> is a dedicated conventional route.</p>
<!-- literal_block {"ids": [], "names": [], "highlight_args": {}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="630" sourceendlinenumber="637"><code class="lang-csharp">app.UseMvc(routes =&gt;
{
    routes.MapRoute(&quot;blog&quot;, &quot;blog/{*article}&quot;,
        defaults: new { controller = &quot;Blog&quot;, action = &quot;Article&quot; });
    routes.MapRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="639" sourceendlinenumber="639">Using these route definitions, <code>Url.Action(&quot;Index&quot;, &quot;Home&quot;)</code> will generate the URL path <code>/</code> with the <code>default</code> route, but why? You might guess the route values <code>{ controller = Home, action = Index }</code> would be enough to generate a URL using <code>blog</code>, and the result would be <code>/blog?action=Index&amp;controller=Home</code>.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="641" sourceendlinenumber="641">Dedicated conventional routes rely on a special behavior of default values that don&#39;t have a corresponding route parameter that prevents the route from being &quot;too greedy&quot; with URL generation. In this case the default values are <code>{ controller = Blog, action = Article }</code>, and neither <code>controller</code> nor <code>action</code> appears as a route parameter. When routing performs URL generation, the values provided must match the default values. URL generation using <code>blog</code> will fail because the values <code>{ controller = Home, action = Index }</code> don&#39;t match <code>{ controller = Blog, action = Article }</code>. Routing then falls back to try <code>default</code>, which succeeds.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="643" sourceendlinenumber="643"><a name="routing-areas-ref-label"></a></p>
<h2 id="areas" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="645" sourceendlinenumber="645">Areas</h2>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="647" sourceendlinenumber="647"><a href="areas.html" data-raw-source="[Areas](areas.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="647" sourceendlinenumber="647">Areas</a> are an MVC feature used to organize related functionality into a group as a separate routing-namespace (for controller actions) and folder structure (for views). Using areas allows an application to have multiple controllers with the same name - as long as they have different <em>areas</em>. Using areas creates a hierarchy for the purpose of routing by adding another route parameter, <code>area</code> to <code>controller</code> and <code>action</code>. This section will discuss how routing interacts with areas - see <a href="areas.html" data-raw-source="[Areas](areas.md)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="647" sourceendlinenumber="647">Areas</a> for details about how areas are used with views.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="649" sourceendlinenumber="649">The following example configures MVC to use the default conventional route and an <em>area route</em> for an area named <code>Blog</code>:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="651" sourceendlinenumber="651"><code class="lang-csharp" name="Main">app.UseMvc(routes =&gt;
{
    routes.MapAreaRoute(&quot;blog_route&quot;, &quot;Blog&quot;,
        &quot;Manage/{controller}/{action}/{id?}&quot;);
    routes.MapRoute(&quot;default_route&quot;, &quot;{controller}/{action}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="653" sourceendlinenumber="653">When matching a URL path like <code>/Manage/Users/AddUser</code>, the first route will produce the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>. The <code>area</code> route value is produced by a default value for <code>area</code>, in fact the route created by <code>MapAreaRoute</code> is equivalent to the following:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="655" sourceendlinenumber="655"><code class="lang-csharp" name="Main">app.UseMvc(routes =&gt;
{
    routes.MapRoute(&quot;blog_route&quot;, &quot;Manage/{controller}/{action}/{id?}&quot;,
        defaults: new { area = &quot;Blog&quot; }, constraints: new { area = &quot;Blog&quot; });
    routes.MapRoute(&quot;default_route&quot;, &quot;{controller}/{action}/{id?}&quot;);
});
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="657" sourceendlinenumber="657"><code>MapAreaRoute</code> creates a route using both a default value and constraint for <code>area</code> using the provided area name, in this case <code>Blog</code>. The default value ensures that the route always produces <code>{ area = Blog, ... }</code>, the constraint requires the value <code>{ area = Blog, ... }</code> for URL generation.</p>
<div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="659" sourceendlinenumber="659"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="660" sourceendlinenumber="660">Conventional routing is order-dependent. In general, routes with areas should be placed earlier in the route table as they are more specific than routes without an area.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="662" sourceendlinenumber="662">Using the above example, the route values would match the following action:</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="664" sourceendlinenumber="664"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area(&quot;Blog&quot;)]
    public class UsersController : Controller
    {
        public IActionResult AddUser()
        {
            return View();
        }        
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="666" sourceendlinenumber="666">The <code>AreaAttribute</code> is what denotes a controller as part of an area, we say that this controller is in the <code>Blog</code> area. Controllers without an <code>[Area]</code> attribute are not members of any area, and will <strong>not</strong> match when the <code>area</code> route value is provided by routing. In the following example, only the first controller listed can match the route values <code>{ area = Blog, controller = Users, action = AddUser }</code>.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="668" sourceendlinenumber="668"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area(&quot;Blog&quot;)]
    public class UsersController : Controller
    {
        public IActionResult AddUser()
        {
            return View();
        }        
    }
}
</code></pre><pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="670" sourceendlinenumber="670"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace2
{
    // Matches { area = Zebra, controller = Users, action = AddUser }
    [Area(&quot;Zebra&quot;)]
    public class UsersController : Controller
    {
        public IActionResult AddUser()
        {
            return View();
        }        
    }
}
</code></pre><pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="672" sourceendlinenumber="672"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace3
{
    // Matches { area = string.Empty, controller = Users, action = AddUser }
    // Matches { area = null, controller = Users, action = AddUser }
    // Matches { controller = Users, action = AddUser }
    public class UsersController : Controller
    {
        public IActionResult AddUser()
        {
            return View();

        }
    }
}
</code></pre><div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="674" sourceendlinenumber="674"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="675" sourceendlinenumber="675">The namespace of each controller is shown here for completeness - otherwise the controllers would have a naming conflict and generate a compiler error. Class namespaces have no effect on MVC&#39;s routing.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="677" sourceendlinenumber="677">The first two controllers are members of areas, and only match when their respective area name is provided by the <code>area</code> route value. The third controller is not a member of any area, and can only match when no value for <code>area</code> is provided by routing.</p>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="679" sourceendlinenumber="679"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="680" sourceendlinenumber="680">In terms of matching <em>no value</em>, the absence of the <code>area</code> value is the same as if the value for <code>area</code> were null or the empty string.</p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="682" sourceendlinenumber="682">When executing an action inside an area, the route value for <code>area</code> will be available as an <em>ambient value</em> for routing to use for URL generation. This means that by default areas act <em>sticky</em> for URL generation as demonstrated by the following sample.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="684" sourceendlinenumber="684"><code class="lang-csharp" name="Main">app.UseMvc(routes =&gt;
{
    routes.MapAreaRoute(&quot;duck_route&quot;, &quot;Duck&quot;,
        &quot;Manage/{controller}/{action}/{id?}&quot;);
    routes.MapRoute(&quot;default&quot;, &quot;Manage/{controller=Home}/{action=Index}/{id?}&quot;);
});
</code></pre><!-- literal_block {"ids": [], "names": [], "highlight_args": {"linenostart": 1}, "backrefs": [], "dupnames": [], "linenos": false, "classes": [], "xml:space": "preserve", "language": "c#", "source": "/Users/shirhatti/src/Docs/aspnet/mvc/controllers/routing/sample/AreasRouting/Areas/Duck/Controllers/UsersController.cs"} -->
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="688" sourceendlinenumber="688"><code class="lang-csharp" name="Main">using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace4
{
    [Area(&quot;Duck&quot;)]
    public class UsersController : Controller
    {
        public IActionResult GenerateURLInArea()
        {
            // Uses the &#39;ambient&#39; value of area
            var url = Url.Action(&quot;Index&quot;, &quot;Home&quot;); 
            // returns /Manage
            return Content(url);
        }

        public IActionResult GenerateURLOutsideOfArea()
        {
            // Uses the empty value for area
            var url = Url.Action(&quot;Index&quot;, &quot;Home&quot;, new { area = &quot;&quot; }); 
            // returns /Manage/Home/Index
            return Content(url);
        }
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="690" sourceendlinenumber="690"><a name="iactionconstraint-ref-label"></a></p>
<h2 id="understanding-iactionconstraint" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="692" sourceendlinenumber="692">Understanding IActionConstraint</h2>
<div class="NOTE" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="694" sourceendlinenumber="694"><h5>Note</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="695" sourceendlinenumber="695">This section is a deep-dive on framework internals and how MVC chooses an action to execute. A typical application won&#39;t need a custom <code>IActionConstraint</code></p>
</div>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="697" sourceendlinenumber="697">You have likely already used <code>IActionConstraint</code> even if you&#39;re not familiar with the interface. The <code>[HttpGet]</code> Attribute and similar <code>[Http-VERB]</code> attributes implement <code>IActionConstraint</code> in order to limit the execution of an action method.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="699" sourceendlinenumber="707"><code class="lang-csharp">public class ProductsController : Controller
{
    [HttpGet]
    public IActionResult Edit() { }

    public IActionResult Edit(...) { }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="709" sourceendlinenumber="709">Assuming the default conventional route, the URL path <code>/Products/Edit</code> would produce the values <code>{ controller = Products, action = Edit }</code>, which would match <strong>both</strong> of the actions shown here. In <code>IActionConstraint</code> terminology we would say that both of these actions are considered candidates - as they both match the route data.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="711" sourceendlinenumber="711">When the <code>HttpGetAttribute</code> executes, it will say that <em>Edit()</em> is a match for <em>GET</em> and is not a match for any other HTTP verb. The <code>Edit(...)</code> action doesn&#39;t have any constraints defined, and so will match any HTTP verb. So assuming a <code>POST</code> - only <code>Edit(...)</code> matches. But, for a <code>GET</code> both actions can still match - however, an action with an <code>IActionConstraint</code> is always considered <em>better</em> than an action without. So because <code>Edit()</code> has <code>[HttpGet]</code> it is considered more specific, and will be selected if both actions can match.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="713" sourceendlinenumber="713">Conceptually, <code>IActionConstraint</code> is a form of <em>overloading</em>, but instead of overloading methods with the same name, it is overloading between actions that match the same URL. Attribute routing also uses <code>IActionConstraint</code> and can result in actions from different controllers both being considered candidates.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="715" sourceendlinenumber="715"><a name="iactionconstraint-impl-ref-label"></a></p>
<h3 id="implementing-iactionconstraint" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="717" sourceendlinenumber="717">Implementing IActionConstraint</h3>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="719" sourceendlinenumber="719">The simplest way to implement an <code>IActionConstraint</code> is to create a class derived from <code>System.Attribute</code> and place it on your actions and controllers. MVC will automatically discover any <code>IActionConstraint</code> that are applied as attributes. You can use the application model to apply constraints, and this is probably the most flexible approach as it allows you to metaprogram how they are applied.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="721" sourceendlinenumber="721">In the following example a constraint chooses an action based on a <em>country code</em> from the route data. The <a href="https://github.com/aspnet/Entropy/blob/dev/samples/Mvc.ActionConstraintSample.Web/CountrySpecificAttribute.cs" data-raw-source="[full sample on GitHub](https://github.com/aspnet/Entropy/blob/dev/samples/Mvc.ActionConstraintSample.Web/CountrySpecificAttribute.cs)" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="721" sourceendlinenumber="721">full sample on GitHub</a>.</p>
<pre sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="723" sourceendlinenumber="749"><code class="lang-csharp">public class CountrySpecificAttribute : Attribute, IActionConstraint
{
    private readonly string _countryCode;

    public CountrySpecificAttribute(string countryCode)
    {
        _countryCode = countryCode;
    }

    public int Order
    {
        get
        {
            return 0;
        }
    }

    public bool Accept(ActionConstraintContext context)
    {
        return string.Equals(
            context.RouteContext.RouteData.Values[&quot;country&quot;].ToString(),
            _countryCode,
            StringComparison.OrdinalIgnoreCase);
    }
}
</code></pre><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="751" sourceendlinenumber="751">You are responsible for implementing the <code>Accept</code> method and choosing an &#39;Order&#39; for the constraint to execute. In this case, the <code>Accept</code> method returns <code>true</code> to denote the action is a match when the <code>country</code> route value matches. This is different from a <code>RouteValueAttribute</code> in that it allows fallback to a non-attributed action. The sample shows that if you define an <code>en-US</code> action then a country code like <code>fr-FR</code> will fall back to a more generic controller that does not have <code>[CountrySpecific(...)]</code> applied.</p>
<p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="753" sourceendlinenumber="753">The <code>Order</code> property decides which <em>stage</em> the constraint is part of. Action constraints run in groups based on the <code>Order</code>. For example, all of the framework provided HTTP method attributes use the same <code>Order</code> value so that they run in the same stage. You can have as many stages as you need to implement your desired policies.</p>
<div class="TIP" sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="755" sourceendlinenumber="755"><h5>Tip</h5><p sourcefile="mvc/controllers/routing.md" sourcestartlinenumber="756" sourceendlinenumber="756">To decide on a value for <code>Order</code> think about whether or not your constraint should be applied before HTTP methods. Lower numbers run first.</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Docs/blob/w/riande/RP-EF/aspnetcore/mvc/controllers/routing.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
